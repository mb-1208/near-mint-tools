use near_contract_standards::non_fungible_token::core::{
    NonFungibleTokenCore, NonFungibleTokenResolver,
};
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};
use near_sdk::env::is_valid_account_id;
use near_sdk::json_types::{ValidAccountId, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, serde_json::json,
    serde_json::value::Value::Null, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault,
    Promise, PromiseOrValue, Timestamp,
};
use std::collections::HashMap;

pub mod event;
pub use event::NearEvent;

/// between token_series_id and edition number e.g. 42:2 where 42 is series and 2 is edition
pub const TOKEN_DELIMETER: char = ':';
/// TokenMetadata.title returned for individual token e.g. "Title — 2/10" where 10 is max copies
pub const TITLE_DELIMETER: &str = " #";
/// e.g. "Title — 2/10" where 10 is max copies
pub const EDITION_DELIMETER: &str = "/";

const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
const GAS_FOR_NFT_TRANSFER_CALL: Gas = 30_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;
const GAS_FOR_NFT_APPROVE: Gas = 10_000_000_000_000;
const GAS_FOR_MINT: Gas = 90_000_000_000_000;
const NO_DEPOSIT: Balance = 0;
const MAX_PRICE: Balance = 1_000_000_000 * 10u128.pow(24);

pub type TokenSeriesId = String;
pub type TimestampSec = u32;
pub type ContractAndTokenId = String;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_approval_receiver)]
pub trait NonFungibleTokenReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
    metadata: TokenMetadata,
    creator_id: AccountId,
    tokens: UnorderedSet<TokenId>,
    price: Option<Balance>,
    is_mintable: bool,
    royalty: HashMap<AccountId, u32>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
    token_series_id: TokenSeriesId,
    metadata: TokenMetadata,
    creator_id: AccountId,
    royalty: HashMap<AccountId, u32>,
    transaction_fee: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransactionFee {
    pub next_fee: Option<u16>,
    pub start_time: Option<TimestampSec>,
    pub current_fee: u16,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MarketDataTransactionFee {
    pub transaction_fee: UnorderedMap<TokenSeriesId, u128>,
}

near_sdk::setup_alloc!();

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContractV1 {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    // CUSTOM
    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    treasury_id: AccountId,
    transaction_fee: TransactionFee,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    // CUSTOM
    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    treasury_id: AccountId,
    transaction_fee: TransactionFee,
    market_data_transaction_fee: MarketDataTransactionFee,
}

const DATA_IMAGE_SVG_PARAS_ICON: &str = "data:image/png;base64,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";
const NAME: &str = "TON Punks";
const SYMBOL: &str = "PUNKS";
const BASE_URI: &str = "https://ipfs.fleek.co/ipfs";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    // CUSTOM
    TokenSeriesById,
    TokensBySeriesInner { token_series: String },
    TokensPerOwner { account_hash: Vec<u8> },
    MarketDataTransactionFee,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, treasury_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            treasury_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: NAME.to_string(),
                symbol: SYMBOL.to_string(),
                icon: Some(DATA_IMAGE_SVG_PARAS_ICON.to_string()),
                base_uri: Some(BASE_URI.to_string()),
                reference: None,
                reference_hash: None,
            },
            500,
        )
    }

    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        treasury_id: ValidAccountId,
        metadata: NFTContractMetadata,
        current_fee: u16,
    ) -> Self {
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            token_series_by_id: UnorderedMap::new(StorageKey::TokenSeriesById),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            treasury_id: treasury_id.to_string(),
            transaction_fee: TransactionFee {
                next_fee: None,
                start_time: None,
                current_fee,
            },
            market_data_transaction_fee: MarketDataTransactionFee {
                transaction_fee: UnorderedMap::new(StorageKey::MarketDataTransactionFee),
            },
        }
    }

    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let prev: ContractV1 = env::state_read().expect("ERR_NOT_INITIALIZED");
        assert_eq!(
            env::predecessor_account_id(),
            prev.tokens.owner_id,
            "Paras: Only owner"
        );

        let this = Contract {
            tokens: prev.tokens,
            metadata: prev.metadata,
            token_series_by_id: prev.token_series_by_id,
            treasury_id: prev.treasury_id,
            transaction_fee: prev.transaction_fee,
            market_data_transaction_fee: MarketDataTransactionFee {
                transaction_fee: UnorderedMap::new(StorageKey::MarketDataTransactionFee),
            },
        };

        this
    }

    #[payable]
    pub fn set_transaction_fee(&mut self, next_fee: u16, start_time: Option<TimestampSec>) {
        assert_one_yocto();
        assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            "Paras: Owner only"
        );

        assert!(
            next_fee < 10_000,
            "Paras: transaction fee is more than 10_000"
        );

        if start_time.is_none() {
            self.transaction_fee.current_fee = next_fee;
            self.transaction_fee.next_fee = None;
            self.transaction_fee.start_time = None;
            return;
        } else {
            let start_time: TimestampSec = start_time.unwrap();
            assert!(
                start_time > to_sec(env::block_timestamp()),
                "start_time is less than current block_timestamp"
            );
            self.transaction_fee.next_fee = Some(next_fee);
            self.transaction_fee.start_time = Some(start_time);
        }
    }

    pub fn calculate_new_market_data_transaction_fee(
        &mut self,
        token_series_id: &TokenSeriesId,
    ) -> u128 {
        if let Some(transaction_fee) = self
            .market_data_transaction_fee
            .transaction_fee
            .get(&token_series_id)
        {
            return transaction_fee;
        }

        self.calculate_current_transaction_fee()
    }

    pub fn calculate_current_transaction_fee(&mut self) -> u128 {
        let transaction_fee: &TransactionFee = &self.transaction_fee;
        if transaction_fee.next_fee.is_some() {
            if to_sec(env::block_timestamp()) >= transaction_fee.start_time.unwrap() {
                self.transaction_fee.current_fee = transaction_fee.next_fee.unwrap();
                self.transaction_fee.next_fee = None;
                self.transaction_fee.start_time = None;
            }
        }
        self.transaction_fee.current_fee as u128
    }

    pub fn get_transaction_fee(&self) -> &TransactionFee {
        &self.transaction_fee
    }

    pub fn get_market_data_transaction_fee(&self, token_series_id: &TokenSeriesId) -> u128 {
        if let Some(transaction_fee) = self
            .market_data_transaction_fee
            .transaction_fee
            .get(&token_series_id)
        {
            return transaction_fee;
        }
        // fallback to default transaction fee
        self.transaction_fee.current_fee as u128
    }

    // Treasury
    #[payable]
    pub fn set_treasury(&mut self, treasury_id: ValidAccountId) {
        assert_one_yocto();
        assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            "Paras: Owner only"
        );
        self.treasury_id = treasury_id.to_string();
    }

    // CUSTOM

    #[payable]
    pub fn nft_create_series(
        &mut self,
        token_metadata: TokenMetadata,
        price: Option<U128>,
        royalty: Option<HashMap<AccountId, u32>>,
    ) -> TokenSeriesJson {
        let initial_storage_usage = env::storage_usage();
        let caller_id = env::predecessor_account_id();

        let token_series_id = format!("{}", (self.token_series_by_id.len() + 1));

        assert!(
            self.token_series_by_id.get(&token_series_id).is_none(),
            "Paras: duplicate token_series_id"
        );

        let title = token_metadata.title.clone();
        assert!(title.is_some(), "Paras: token_metadata.title is required");

        let mut total_perpetual = 0;
        let mut total_accounts = 0;
        let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
            for (k, v) in royalty.iter() {
                if !is_valid_account_id(k.as_bytes()) {
                    env::panic("Not valid account_id for royalty".as_bytes());
                };
                total_perpetual += *v;
                total_accounts += 1;
            }
            royalty
        } else {
            HashMap::new()
        };

        assert!(total_accounts <= 50, "Paras: royalty exceeds 50 accounts");

        assert!(
            total_perpetual <= 9000,
            "Paras Exceeds maximum royalty -> 9000",
        );

        let price_res: Option<u128> = if price.is_some() {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "Paras: price higher than {}",
                MAX_PRICE
            );
            Some(price.unwrap().0)
        } else {
            None
        };

        self.token_series_by_id.insert(
            &token_series_id,
            &TokenSeries {
                metadata: token_metadata.clone(),
                creator_id: caller_id.to_string(),
                tokens: UnorderedSet::new(
                    StorageKey::TokensBySeriesInner {
                        token_series: token_series_id.clone(),
                    }
                    .try_to_vec()
                    .unwrap(),
                ),
                price: price_res,
                is_mintable: true,
                royalty: royalty_res.clone(),
            },
        );

        // set market data transaction fee
        let current_transaction_fee = self.calculate_current_transaction_fee();
        self.market_data_transaction_fee
            .transaction_fee
            .insert(&token_series_id, &current_transaction_fee);

        env::log(
            json!({
                "type": "nft_create_series",
                "params": {
                    "token_series_id": token_series_id,
                    "token_metadata": token_metadata,
                    "creator_id": caller_id,
                    "price": price,
                    "royalty": royalty_res,
                    "transaction_fee": &current_transaction_fee.to_string()
                }
            })
            .to_string()
            .as_bytes(),
        );

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        TokenSeriesJson {
            token_series_id,
            metadata: token_metadata,
            creator_id: caller_id.into(),
            royalty: royalty_res,
            transaction_fee: current_transaction_fee.into(),
        }
    }

    #[payable]
    pub fn nft_buy(
        &mut self,
        token_series_id: TokenSeriesId,
        receiver_id: Option<ValidAccountId>,
    ) -> TokenId {
        let initial_storage_usage = env::storage_usage();
        let attached_deposit = env::attached_deposit();
        let token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Paras: Token series not exist");
        let price: u128 = token_series.price.expect("Paras: not for sale");
        let receiver_id: AccountId = if let Some(receiver_id) = receiver_id {
            receiver_id.to_string()
        } else {
            env::predecessor_account_id()
        };
        assert!(
            attached_deposit >= price,
            "Paras: attached deposit is less than price : {}",
            price
        );
        let token_id: TokenId = self._nft_mint_series(token_series_id.clone(), receiver_id.clone());

        let for_treasury = price as u128
            * self.calculate_new_market_data_transaction_fee(&token_series_id)
            / 10_000u128;
        let price_deducted = price - for_treasury;
        Promise::new(token_series.creator_id).transfer(price_deducted);

        if for_treasury != 0 {
            Promise::new(self.treasury_id.clone()).transfer(for_treasury);
        }

        refund_deposit(env::storage_usage() - initial_storage_usage, price);

        NearEvent::log_nft_mint(
            receiver_id,
            vec![token_id.clone()],
            Some(json!({"price": price.to_string()}).to_string()),
        );

        token_id
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_series_id: TokenSeriesId,
        receiver_id: ValidAccountId,
    ) -> TokenId {
        let initial_storage_usage = env::storage_usage();

        let token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Paras: Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Paras: not creator"
        );
        let token_id: TokenId = self._nft_mint_series(token_series_id, receiver_id.to_string());

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        NearEvent::log_nft_mint(receiver_id.to_string(), vec![token_id.clone()], None);

        token_id
    }

    #[payable]
    pub fn nft_mint_and_approve(
        &mut self,
        token_series_id: TokenSeriesId,
        account_id: ValidAccountId,
        msg: Option<String>,
    ) -> Option<Promise> {
        let initial_storage_usage = env::storage_usage();

        let token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Paras: Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Paras: not creator"
        );
        let token_id: TokenId =
            self._nft_mint_series(token_series_id, token_series.creator_id.clone());

        // Need to copy the nft_approve code here to solve the gas problem
        // get contract-level LookupMap of token_id to approvals HashMap
        let approvals_by_id = self.tokens.approvals_by_id.as_mut().unwrap();

        // update HashMap of approvals for this token
        let approved_account_ids = &mut approvals_by_id
            .get(&token_id)
            .unwrap_or_else(|| HashMap::new());
        let account_id: AccountId = account_id.into();
        let approval_id: u64 = self
            .tokens
            .next_approval_id_by_id
            .as_ref()
            .unwrap()
            .get(&token_id)
            .unwrap_or_else(|| 1u64);
        approved_account_ids.insert(account_id.clone(), approval_id);

        // save updated approvals HashMap to contract's LookupMap
        approvals_by_id.insert(&token_id, &approved_account_ids);

        // increment next_approval_id for this token
        self.tokens
            .next_approval_id_by_id
            .as_mut()
            .unwrap()
            .insert(&token_id, &(approval_id + 1));

        refund_deposit(env::storage_usage() - initial_storage_usage, 0);

        NearEvent::log_nft_mint(
            token_series.creator_id.clone(),
            vec![token_id.clone()],
            None,
        );

        if let Some(msg) = msg {
            Some(ext_approval_receiver::nft_on_approve(
                token_id,
                token_series.creator_id,
                approval_id,
                msg,
                &account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE - GAS_FOR_MINT,
            ))
        } else {
            None
        }
    }

    fn _nft_mint_series(
        &mut self,
        token_series_id: TokenSeriesId,
        receiver_id: AccountId,
    ) -> TokenId {
        let mut token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Paras: Token series not exist");
        assert!(
            token_series.is_mintable,
            "Paras: Token series is not mintable"
        );

        let num_tokens = token_series.tokens.len();
        let max_copies = token_series.metadata.copies.unwrap_or(u64::MAX);
        assert!(num_tokens < max_copies, "Series supply maxed");

        if (num_tokens + 1) >= max_copies {
            token_series.is_mintable = false;
            token_series.price = None;
        }

        let token_id = format!("{}{}{}", &token_series_id, TOKEN_DELIMETER, num_tokens + 1);
        token_series.tokens.insert(&token_id);
        self.token_series_by_id
            .insert(&token_series_id, &token_series);

        // you can add custom metadata to each token here
        let metadata = Some(TokenMetadata {
            title: None,       // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
            description: None, // free-form description
            media: None, // URL to associated media, preferably to decentralized, content-addressed storage
            media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
            copies: None, // number of copies of this set of metadata in existence when token was minted.
            issued_at: Some(env::block_timestamp().to_string()), // ISO 8601 datetime when token was issued or minted
            expires_at: None,     // ISO 8601 datetime when token expires
            starts_at: None,      // ISO 8601 datetime when token starts being valid
            updated_at: None,     // ISO 8601 datetime when token was last updated
            extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
            reference: None, // URL to an off-chain JSON file with more info.
            reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        });

        //let token = self.tokens.mint(token_id, receiver_id, metadata);
        // From : https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs#L359
        // This allows lazy minting

        let owner_id: AccountId = receiver_id;
        self.tokens.owner_by_id.insert(&token_id, &owner_id);

        self.tokens
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &metadata.as_ref().unwrap()));

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(&owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        token_id
    }

    #[payable]
    pub fn nft_decrease_series_copies(
        &mut self,
        token_series_id: TokenSeriesId,
        decrease_copies: U64,
    ) -> U64 {
        assert_one_yocto();

        let mut token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Paras: Creator only"
        );

        let minted_copies = token_series.tokens.len();
        let copies = token_series.metadata.copies.unwrap();

        assert!(
            (copies - decrease_copies.0) >= minted_copies,
            "Paras: cannot decrease supply, already minted : {}",
            minted_copies
        );

        let is_non_mintable = if (copies - decrease_copies.0) == minted_copies {
            token_series.is_mintable = false;
            token_series.price = None;

            env::log(
                json!({
                    "type": "nft_set_series_price",
                    "params": {
                        "token_series_id": token_series_id,
                        "price": Null,
                    }
                })
                .to_string()
                .as_bytes(),
            );

            true
        } else {
            false
        };

        token_series.metadata.copies = Some(copies - decrease_copies.0);

        self.token_series_by_id
            .insert(&token_series_id, &token_series);
        env::log(
            json!({
                "type": "nft_decrease_series_copies",
                "params": {
                    "token_series_id": token_series_id,
                    "copies": U64::from(token_series.metadata.copies.unwrap()),
                    "is_non_mintable": is_non_mintable,
                }
            })
            .to_string()
            .as_bytes(),
        );
        U64::from(token_series.metadata.copies.unwrap())
    }

    #[payable]
    pub fn nft_set_series_price(
        &mut self,
        token_series_id: TokenSeriesId,
        price: Option<U128>,
    ) -> Option<U128> {
        assert_one_yocto();

        let mut token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Token series not exist");
        assert_eq!(
            env::predecessor_account_id(),
            token_series.creator_id,
            "Paras: Creator only"
        );

        assert_eq!(
            token_series.is_mintable, true,
            "Paras: token series is not mintable"
        );

        if price.is_none() {
            token_series.price = None;
        } else {
            assert!(
                price.unwrap().0 < MAX_PRICE,
                "Paras: price higher than {}",
                MAX_PRICE
            );
            token_series.price = Some(price.unwrap().0);
        }

        self.token_series_by_id
            .insert(&token_series_id, &token_series);

        // set market data transaction fee
        let current_transaction_fee = self.calculate_current_transaction_fee();
        self.market_data_transaction_fee
            .transaction_fee
            .insert(&token_series_id, &current_transaction_fee);

        env::log(
            json!({
                "type": "nft_set_series_price",
                "params": {
                    "token_series_id": token_series_id,
                    "price": price,
                    "transaction_fee": current_transaction_fee.to_string()
                }
            })
            .to_string()
            .as_bytes(),
        );
        return price;
    }

    #[payable]
    pub fn nft_burn(&mut self, token_id: TokenId) {
        assert_one_yocto();

        let owner_id = self.tokens.owner_by_id.get(&token_id).unwrap();
        assert_eq!(owner_id, env::predecessor_account_id(), "Token owner only");

        if let Some(next_approval_id_by_id) = &mut self.tokens.next_approval_id_by_id {
            next_approval_id_by_id.remove(&token_id);
        }

        if let Some(approvals_by_id) = &mut self.tokens.approvals_by_id {
            approvals_by_id.remove(&token_id);
        }

        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap();
            token_ids.remove(&token_id);

            // remove the owner if there are no more tokens
            if token_ids.is_empty() {
                tokens_per_owner.remove(&owner_id);
            } else {
                tokens_per_owner.insert(&owner_id, &token_ids);
            }
        }

        if let Some(token_metadata_by_id) = &mut self.tokens.token_metadata_by_id {
            token_metadata_by_id.remove(&token_id);
        }

        self.tokens.owner_by_id.remove(&token_id);

        NearEvent::log_nft_burn(owner_id, vec![token_id], None, None);
    }

    // CUSTOM VIEWS

    pub fn nft_get_series_single(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson {
        let token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Series does not exist");
        let current_transaction_fee = self.get_market_data_transaction_fee(&token_series_id);
        TokenSeriesJson {
            token_series_id,
            metadata: token_series.metadata,
            creator_id: token_series.creator_id,
            royalty: token_series.royalty,
            transaction_fee: current_transaction_fee.into(),
        }
    }

    pub fn nft_get_series_format(self) -> (char, &'static str, &'static str) {
        (TOKEN_DELIMETER, TITLE_DELIMETER, EDITION_DELIMETER)
    }

    pub fn nft_get_series_price(self, token_series_id: TokenSeriesId) -> Option<U128> {
        let price = self.token_series_by_id.get(&token_series_id).unwrap().price;
        match price {
            Some(p) => return Some(U128::from(p)),
            None => return None,
        };
    }

    pub fn nft_get_series(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<TokenSeriesJson> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_series_id, token_series)| {
                let current_transaction_fee =
                    self.get_market_data_transaction_fee(&token_series_id);
                return TokenSeriesJson {
                    token_series_id,
                    metadata: token_series.metadata,
                    creator_id: token_series.creator_id,
                    royalty: token_series.royalty,
                    transaction_fee: current_transaction_fee.into(),
                };
            })
            .collect()
    }

    pub fn nft_supply_for_series(&self, token_series_id: TokenSeriesId) -> U64 {
        self.token_series_by_id
            .get(&token_series_id)
            .expect("Token series not exist")
            .tokens
            .len()
            .into()
    }

    pub fn nft_tokens_by_series(
        &self,
        token_series_id: TokenSeriesId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        let tokens = self
            .token_series_by_id
            .get(&token_series_id)
            .unwrap()
            .tokens;
        assert!(
            (tokens.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        tokens
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<Token> {
        let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let approved_account_ids = self
            .tokens
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));

        // CUSTOM (switch metadata for the token_series metadata)
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let series_metadata = self
            .token_series_by_id
            .get(&token_series_id)
            .unwrap()
            .metadata;

        let mut token_metadata = self
            .tokens
            .token_metadata_by_id
            .as_ref()
            .unwrap()
            .get(&token_id)
            .unwrap();

        token_metadata.title = Some(format!("{}", series_metadata.title.unwrap()));

        token_metadata.reference = series_metadata.reference;
        token_metadata.media = series_metadata.media;
        token_metadata.copies = series_metadata.copies;
        token_metadata.extra = series_metadata.extra;

        Some(Token {
            token_id,
            owner_id,
            metadata: Some(token_metadata),
            approved_account_ids,
        })
    }

    #[payable]
    pub fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        let sender_id = env::predecessor_account_id();
        let previous_owner_id = self
            .tokens
            .owner_by_id
            .get(&token_id)
            .expect("Token not found");
        let receiver_id_str = receiver_id.to_string();
        self.tokens
            .nft_transfer(receiver_id, token_id.clone(), approval_id, memo.clone());

        let authorized_id: Option<AccountId> = if sender_id != previous_owner_id {
            Some(sender_id)
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id,
            receiver_id_str,
            vec![token_id],
            memo,
            authorized_id,
        );
    }

    #[payable]
    pub fn nft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let (previous_owner_id, old_approvals) = self.tokens.internal_transfer(
            &sender_id,
            receiver_id.as_ref(),
            &token_id,
            approval_id,
            memo.clone(),
        );

        let authorized_id: Option<AccountId> = if sender_id != previous_owner_id {
            Some(sender_id.clone())
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id.clone(),
            receiver_id.to_string(),
            vec![token_id.clone()],
            memo,
            authorized_id,
        );

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL,
        )
        .then(ext_self::nft_resolve_transfer(
            previous_owner_id,
            receiver_id.into(),
            token_id,
            old_approvals,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()
    }

    // CUSTOM enumeration standard modified here because no macro below

    pub fn nft_total_supply(&self) -> U128 {
        (self.tokens.owner_by_id.len() as u128).into()
    }

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token> {
        // Get starting index, whether or not it was explicitly given.
        // Defaults to 0 based on the spec:
        // https://nomicon.io/Standards/NonFungibleToken/Enumeration.html#interface
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.tokens.owner_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, _)| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128 {
        let tokens_per_owner = self.tokens.tokens_per_owner.expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        tokens_per_owner
            .get(account_id.as_ref())
            .map(|account_tokens| U128::from(account_tokens.len() as u128))
            .unwrap_or(U128(0))
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: ValidAccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().expect(
            "Could not find tokens_per_owner when calling a method on the enumeration standard.",
        );
        let token_set = if let Some(token_set) = tokens_per_owner.get(account_id.as_ref()) {
            token_set
        } else {
            return vec![];
        };
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        token_set
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.nft_token(token_id).unwrap())
            .collect()
    }

    pub fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        let owner_id = self.tokens.owner_by_id.get(&token_id).expect("No token id");
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let royalty = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("no type")
            .royalty;

        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        let balance_u128: u128 = balance.into();

        let mut payout: Payout = Payout {
            payout: HashMap::new(),
        };
        let mut total_perpetual = 0;

        for (k, v) in royalty.iter() {
            if *k != owner_id {
                let key = k.clone();
                payout
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );
        payout
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        balance: Option<U128>,
        max_len_payout: Option<u32>,
    ) -> Option<Payout> {
        assert_one_yocto();

        let sender_id = env::predecessor_account_id();
        // Transfer
        let previous_token = self.nft_token(token_id.clone()).expect("no token");
        self.tokens
            .nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, None);

        // Payout calculation
        let previous_owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let payout = if let Some(balance) = balance {
            let balance_u128: u128 = u128::from(balance);
            let mut payout: Payout = Payout {
                payout: HashMap::new(),
            };

            let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
            let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
            let royalty = self
                .token_series_by_id
                .get(&token_series_id)
                .expect("no type")
                .royalty;

            assert!(
                royalty.len() as u32 <= max_len_payout.unwrap(),
                "Market cannot payout to that many receivers"
            );
            for (k, v) in royalty.iter() {
                let key = k.clone();
                if key != previous_owner_id {
                    payout
                        .payout
                        .insert(key, royalty_to_payout(*v, balance_u128));
                    total_perpetual += *v;
                }
            }

            assert!(total_perpetual <= 10000, "Total payout overflow");

            payout.payout.insert(
                previous_owner_id.clone(),
                royalty_to_payout(10000 - total_perpetual, balance_u128),
            );
            Some(payout)
        } else {
            None
        };

        let authorized_id: Option<AccountId> = if sender_id != previous_owner_id {
            Some(sender_id)
        } else {
            None
        };

        NearEvent::log_nft_transfer(
            previous_owner_id,
            receiver_id.to_string(),
            vec![token_id],
            None,
            authorized_id,
        );

        payout
    }

    pub fn get_owner(&self) -> AccountId {
        self.tokens.owner_id.clone()
    }
}

fn royalty_to_payout(a: u32, b: Balance) -> U128 {
    U128(a as u128 * b / 10_000u128)
}

// near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
// near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool {
        let resp: bool = self.tokens.nft_resolve_transfer(
            previous_owner_id.clone(),
            receiver_id.clone(),
            token_id.clone(),
            approved_account_ids,
        );

        // if not successful, return nft back to original owner
        if !resp {
            NearEvent::log_nft_transfer(receiver_id, previous_owner_id, vec![token_id], None, None);
        }

        resp
    }
}

/// from https://github.com/near/near-sdk-rs/blob/e4abb739ff953b06d718037aa1b8ab768db17348/near-contract-standards/src/non_fungible_token/utils.rs#L29

fn refund_deposit(storage_used: u64, extra_spend: Balance) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit() - extra_spend;

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

fn to_sec(timestamp: Timestamp) -> TimestampSec {
    (timestamp / 10u64.pow(9)) as u32
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;

    const STORAGE_FOR_CREATE_SERIES: Balance = 8540000000000000000000;
    const STORAGE_FOR_MINT: Balance = 11280000000000000000000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn setup_contract() -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let contract = Contract::new_default_meta(accounts(0), accounts(4));
        (context, contract)
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new(
            accounts(1),
            accounts(4),
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Triple Triad".to_string(),
                symbol: "TRIAD".to_string(),
                icon: Some(DATA_IMAGE_SVG_PARAS_ICON.to_string()),
                base_uri: Some("https://ipfs.fleek.co/ipfs/".to_string()),
                reference: None,
                reference_hash: None,
            },
            500,
        );
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.get_owner(), accounts(1).to_string());
        assert_eq!(
            contract.nft_metadata().base_uri.unwrap(),
            "https://ipfs.fleek.co/ipfs/".to_string()
        );
        assert_eq!(
            contract.nft_metadata().icon.unwrap(),
            DATA_IMAGE_SVG_PARAS_ICON.to_string()
        );
    }

    fn create_series(
        contract: &mut Contract,
        royalty: &HashMap<AccountId, u32>,
        price: Option<U128>,
        copies: Option<u64>,
    ) {
        contract.nft_create_series(
            TokenMetadata {
                title: Some("Tsundere land".to_string()),
                description: None,
                media: Some(
                    "bafybeidzcan4nzcz7sczs4yzyxly4galgygnbjewipj6haco4kffoqpkiy".to_string(),
                ),
                media_hash: None,
                copies: copies,
                issued_at: None,
                expires_at: None,
                starts_at: None,
                updated_at: None,
                extra: None,
                reference: Some(
                    "bafybeicg4ss7qh5odijfn2eogizuxkrdh3zlv4eftcmgnljwu7dm64uwji".to_string(),
                ),
                reference_hash: None,
            },
            price,
            Some(royalty.clone()),
        );
    }

    #[test]
    fn test_create_series() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);
        create_series(
            &mut contract,
            &royalty,
            Some(U128::from(1 * 10u128.pow(24))),
            None,
        );

        let nft_series_return = contract.nft_get_series_single("1".to_string());
        assert_eq!(nft_series_return.creator_id, accounts(1).to_string());

        assert_eq!(nft_series_return.token_series_id, "1",);

        assert_eq!(nft_series_return.royalty, royalty,);

        assert!(nft_series_return.metadata.copies.is_none());

        assert_eq!(
            nft_series_return.metadata.title.unwrap(),
            "Tsundere land".to_string()
        );

        assert_eq!(
            nft_series_return.metadata.reference.unwrap(),
            "bafybeicg4ss7qh5odijfn2eogizuxkrdh3zlv4eftcmgnljwu7dm64uwji".to_string()
        );
    }

    #[test]
    fn test_buy() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(
            &mut contract,
            &royalty,
            Some(U128::from(1 * 10u128.pow(24))),
            None,
        );

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1 * 10u128.pow(24) + STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_buy("1".to_string(), Some(accounts(3)));

        let token_from_nft_token = contract.nft_token(token_id);
        assert_eq!(
            token_from_nft_token.unwrap().owner_id,
            accounts(3).to_string()
        );

        let token_id = contract.nft_buy("1".to_string(), None);

        let token_from_nft_token = contract.nft_token(token_id);
        assert_eq!(
            token_from_nft_token.unwrap().owner_id,
            accounts(2).to_string()
        );
    }

    #[test]
    fn test_mint() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, None);

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_mint("1".to_string(), accounts(2));

        let token_from_nft_token = contract.nft_token(token_id);
        assert_eq!(
            token_from_nft_token.unwrap().owner_id,
            accounts(2).to_string()
        )
    }

    #[test]
    #[should_panic(expected = "Paras: Token series is not mintable")]
    fn test_invalid_mint_above_copies() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, Some(1));

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        contract.nft_mint("1".to_string(), accounts(2));
        contract.nft_mint("1".to_string(), accounts(2));
    }

    #[test]
    fn test_decrease_copies() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, Some(5));

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        contract.nft_mint("1".to_string(), accounts(2));
        contract.nft_mint("1".to_string(), accounts(2));

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());

        contract.nft_decrease_series_copies("1".to_string(), U64::from(3));
    }

    #[test]
    #[should_panic(expected = "Paras: cannot decrease supply, already minted : 2")]
    fn test_invalid_decrease_copies() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, Some(5));

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        contract.nft_mint("1".to_string(), accounts(2));
        contract.nft_mint("1".to_string(), accounts(2));

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());

        contract.nft_decrease_series_copies("1".to_string(), U64::from(4));
    }

    #[test]
    #[should_panic(expected = "Paras: not for sale")]
    fn test_invalid_buy_price_null() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(
            &mut contract,
            &royalty,
            Some(U128::from(1 * 10u128.pow(24))),
            None,
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());

        contract.nft_set_series_price("1".to_string(), None);

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1 * 10u128.pow(24) + STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_buy("1".to_string(), Some(accounts(2)));

        let token_from_nft_token = contract.nft_token(token_id);
        assert_eq!(
            token_from_nft_token.unwrap().owner_id,
            accounts(2).to_string()
        )
    }

    #[test]
    #[should_panic(expected = "Paras: price higher than 1000000000000000000000000000000000")]
    fn test_invalid_price_shouldnt_be_higher_than_max_price() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(
            &mut contract,
            &royalty,
            Some(U128::from(1_000_000_000 * 10u128.pow(24))),
            None,
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(1)
            .build());
    }

    #[test]
    fn test_nft_burn() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, None);

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_mint("1".to_string(), accounts(2));

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1)
            .build());

        contract.nft_burn(token_id.clone());
        let token = contract.nft_token(token_id);
        assert!(token.is_none());
    }

    #[test]
    fn test_nft_transfer() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, None);

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_mint("1".to_string(), accounts(2));

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1)
            .build());

        contract.nft_transfer(accounts(3), token_id.clone(), None, None);

        let token = contract.nft_token(token_id).unwrap();
        assert_eq!(token.owner_id, accounts(3).to_string())
    }

    #[test]
    fn test_nft_transfer_payout() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        create_series(&mut contract, &royalty, None, None);

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .attached_deposit(STORAGE_FOR_MINT)
            .build());

        let token_id = contract.nft_mint("1".to_string(), accounts(2));

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1)
            .build());

        let payout = contract.nft_transfer_payout(
            accounts(3),
            token_id.clone(),
            Some(0),
            Some(U128::from(1 * 10u128.pow(24))),
            Some(10),
        );

        let mut payout_calc: HashMap<AccountId, U128> = HashMap::new();
        payout_calc.insert(
            accounts(1).to_string(),
            U128::from((1000 * (1 * 10u128.pow(24))) / 10_000),
        );
        payout_calc.insert(
            accounts(2).to_string(),
            U128::from((9000 * (1 * 10u128.pow(24))) / 10_000),
        );

        assert_eq!(payout.unwrap().payout, payout_calc);

        let token = contract.nft_token(token_id).unwrap();
        assert_eq!(token.owner_id, accounts(3).to_string())
    }

    #[test]
    fn test_change_transaction_fee_immediately() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.set_transaction_fee(100, None);

        assert_eq!(contract.get_transaction_fee().current_fee, 100);
    }

    #[test]
    fn test_change_transaction_fee_with_time() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let next_fee: u16 = 100;
        let start_time: Timestamp = 1618109122863866400;
        let start_time_sec: TimestampSec = to_sec(start_time);
        contract.set_transaction_fee(next_fee, Some(start_time_sec));

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, Some(next_fee));
        assert_eq!(
            contract.get_transaction_fee().start_time,
            Some(start_time_sec)
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .block_timestamp(start_time + 1)
            .build());

        contract.calculate_current_transaction_fee();
        assert_eq!(contract.get_transaction_fee().current_fee, next_fee);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);
    }

    #[test]
    fn test_transaction_fee_locked() {
        let (mut context, mut contract) = setup_contract();

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let next_fee: u16 = 100;
        let start_time: Timestamp = 1618109122863866400;
        let start_time_sec: TimestampSec = to_sec(start_time);
        contract.set_transaction_fee(next_fee, Some(start_time_sec));

        let mut royalty: HashMap<AccountId, u32> = HashMap::new();
        royalty.insert(accounts(1).to_string(), 1000);

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(STORAGE_FOR_CREATE_SERIES)
            .build());

        create_series(
            &mut contract,
            &royalty,
            Some(U128::from(1 * 10u128.pow(24))),
            None,
        );

        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build());

        contract.nft_set_series_price("1".to_string(), None);

        assert_eq!(contract.get_transaction_fee().current_fee, 500);
        assert_eq!(contract.get_transaction_fee().next_fee, Some(next_fee));
        assert_eq!(
            contract.get_transaction_fee().start_time,
            Some(start_time_sec)
        );

        testing_env!(context
            .predecessor_account_id(accounts(1))
            .block_timestamp(start_time + 1)
            .attached_deposit(1)
            .build());

        contract.calculate_current_transaction_fee();
        assert_eq!(contract.get_transaction_fee().current_fee, next_fee);
        assert_eq!(contract.get_transaction_fee().next_fee, None);
        assert_eq!(contract.get_transaction_fee().start_time, None);

        let series = contract.nft_get_series_single("1".to_string());
        let series_transaction_fee: u128 = series.transaction_fee.0;
        assert_eq!(series_transaction_fee, 500);
    }
}
